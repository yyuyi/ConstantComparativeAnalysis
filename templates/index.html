<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Constant Comparative Analysis Agent App</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}" />
  </head>
  <body>
    
    <main class="container">
      <header>
        <h1>Constant Comparative Analysis</h1>
        <p class="lede">Automate Constant Comparative Analysis with Agentic AI.</p>
      </header>
      <form id="run_form" action="{{ url_for('start') }}" method="post" enctype="multipart/form-data" class="grid">
        <details class="panel" id="run-panel" open>
          <summary><span>Run Settings</span><span class="caret">▾</span></summary>
          <div class="panel-content">
          <div class="field">
            <label for="openai_api_key">OpenAI API Key</label>
            <input type="password" id="openai_api_key" name="openai_api_key" placeholder="sk-..." required />
            <div class="help">Required to run this analysis.</div>
          </div>
          <div class="field">
            <label for="transcripts">Transcripts (.txt, .pdf, .docx)</label>
            <input type="file" id="transcripts" name="transcripts" accept=".txt,.pdf,.docx" multiple required />
            <div class="help">Upload one file per interview or focus group.</div>
          </div>
          <div class="field">
            <label for="coders">Coders</label>
            <select id="coders" name="coders">
              <option value="1" selected>1</option>
              <option value="2">2</option>
            </select>
            <div class="help">Choose either a single coder run or a two-coder comparison.</div>
          </div>
          <div class="field">
            <label>Analysis Mode</label>
            <div>
              <label><input type="radio" name="analysis_mode" value="classic" checked /> Classic</label>
              <label style="margin-left:12px;"><input type="radio" name="analysis_mode" value="interpretive" /> Interpretive</label>
              <label style="margin-left:12px;"><input type="radio" name="analysis_mode" value="constructionist" /> Constructionist</label>
            </div>
            <div class="help">Classic: no framework. Interpretive: framework suggestive. Constructionist: framework required.</div>
          </div>
          <div id="tf-inline" style="display:none;">
            <div class="field">
              <label for="theoretical_framework">Theoretical Framework</label>
              <textarea id="theoretical_framework" name="theoretical_framework" placeholder="e.g., Activity Theory, Social Constructionism"></textarea>
              <div class="help" id="theoretical_framework_counter">1000 words left</div>
            </div>
            <div class="actions">
              <button type="button" class="btn" id="refine_tf_btn">Revise</button>
              <button type="button" class="btn secondary" id="revert_tf_btn" disabled>Revert</button>
              <span id="status_tf" class="status"></span>
            </div>
          </div>
          <div class="field">
            <label><input type="checkbox" name="cac_enabled" /> Enable CAC reasoning</label>
            <div class="help">Emphasize Condition–Action–Consequence relationships when possible.</div>
          </div>
          <div class="field">
            <label>Categories</label>
            <div class="actions" style="margin-top:0;">
              <label><input type="checkbox" name="auto_categories" id="auto_categories" checked /> Auto-determine</label>
              <input type="number" name="max_categories" id="max_categories" min="1" placeholder="Max (optional)" style="max-width: 140px; margin-left: 8px;" />
            </div>
            <div class="help">Leave Auto on to let the agent choose a data-driven number of comparative categories. If provided, the agent produces ≤ this number.</div>
          </div>
          <div class="field">
            <label for="segment_length">Segment Length (tokens)</label>
            <select id="segment_length" name="segment_length">
              {% for opt in segment_length_options %}
                <option value="{{ opt }}" {% if opt == default_segment_len %}selected{% endif %}>{{ opt }}</option>
              {% endfor %}
            </select>
          </div>
          <div class="field">
            <label for="model">Model</label>
            <select id="model" name="model">
              {% for m in model_options %}
                <option value="{{ m }}" {% if m == default_model %}selected{% endif %}>{{ m }}</option>
              {% endfor %}
            </select>
            <div class="help">Higher-capability models may yield better analytic quality.</div>
          </div>
          </div>
        </details>

        <details class="panel" id="bg-panel" open>
          <summary>
            <span>Study Background</span>
            <span class="caret">▾</span>
          </summary>
          <div class="panel-content">
            <div class="field">
              <label for="study_background">Context and objectives</label>
              <textarea id="study_background" name="study_background" required placeholder="Describe the study context, aims, and key constructs..."></textarea>
              <div class="help" id="study_background_counter">1000 words left</div>
            </div>
            <div class="actions">
              <button type="button" class="btn" id="refine_bg_btn">Revise</button>
              <button type="button" class="btn secondary" id="revert_bg_btn" disabled>Revert</button>
              <span id="status_bg" class="status"></span>
            </div>
          </div>
        </details>

        <div class="panel" style="grid-column: 1 / -1; display:flex; justify-content:flex-end;">
          <button type="submit" class="btn">Run Agent Analysis</button>
        </div>
      </form>
    </main>
    <script>
      const WORD_LIMIT_BG = 1000;
      const WORD_LIMIT_TF = 1000;

      function applyWordLimit(textarea, limit) {
        if (!textarea) return 0;
        const text = textarea.value;
        const matches = Array.from(text.matchAll(/\S+/g));
        if (matches.length > limit) {
          const cutoffMatch = matches[limit - 1];
          const cutoff = cutoffMatch.index + cutoffMatch[0].length;
          textarea.value = text.slice(0, cutoff).trimEnd();
          return limit;
        }
        return matches.length;
      }

      function updateWordCounter(textarea, counterEl, limit) {
        if (!textarea || !counterEl) return;
        const words = applyWordLimit(textarea, limit);
        const remaining = Math.max(0, limit - words);
        counterEl.textContent = `${remaining} word${remaining === 1 ? '' : 's'} left`;
      }

      function setupWordLimit(textareaId, counterId, limit) {
        const textarea = document.getElementById(textareaId);
        const counterEl = document.getElementById(counterId);
        if (!textarea || !counterEl) {
          return { textarea: null, counter: null, update: () => {} };
        }
        const update = () => updateWordCounter(textarea, counterEl, limit);
        textarea.addEventListener('input', update);
        update();
        return { textarea, counter: counterEl, limit, update };
      }

      let bgLimiter = null;
      let tfLimiter = null;

      function updateTFVisibility() {
        const mode = document.querySelector('input[name="analysis_mode"]:checked')?.value;
        const tfInline = document.getElementById('tf-inline');
        if (!tfInline) return;
        if (mode === 'interpretive' || mode === 'constructionist') {
          tfInline.style.display = '';
          if (tfLimiter && typeof tfLimiter.update === 'function') tfLimiter.update();
        } else {
          tfInline.style.display = 'none';
          const input = document.getElementById('theoretical_framework');
          if (input) {
            input.value = '';
            if (tfLimiter && typeof tfLimiter.update === 'function') tfLimiter.update();
          }
        }
      }

      function updateMaxCatState() {
        const auto = document.getElementById('auto_categories');
        const num = document.getElementById('max_categories');
        if (auto && num) {
          num.disabled = auto.checked;
          if (auto.checked) num.value = '';
        }
      }

      bgLimiter = setupWordLimit('study_background', 'study_background_counter', WORD_LIMIT_BG);
      tfLimiter = setupWordLimit('theoretical_framework', 'theoretical_framework_counter', WORD_LIMIT_TF);

      document.querySelectorAll('input[name="analysis_mode"]').forEach(el => el.addEventListener('change', updateTFVisibility));
      const autoEl = document.getElementById('auto_categories');
      if (autoEl) autoEl.addEventListener('change', updateMaxCatState);
      updateTFVisibility();
      updateMaxCatState();

      const snapshots = { bg: null, tf: null };
      async function refineField(kind) {
        const mode = document.querySelector('input[name="analysis_mode"]:checked')?.value || 'classic';
        const key = document.getElementById('openai_api_key').value || '';
        const sbEl = document.getElementById('study_background');
        const tfEl = document.getElementById('theoretical_framework');
        const statusEl = document.getElementById(kind === 'bg' ? 'status_bg' : 'status_tf');
        const revertBtn = document.getElementById(kind === 'bg' ? 'revert_bg_btn' : 'revert_tf_btn');
        const refineBtn = document.getElementById(kind === 'bg' ? 'refine_bg_btn' : 'refine_tf_btn');
        if (kind === 'bg' && bgLimiter && typeof bgLimiter.update === 'function') bgLimiter.update();
        if (kind === 'tf' && tfLimiter && typeof tfLimiter.update === 'function') tfLimiter.update();
        const sb = sbEl.value;
        const tf = tfEl ? tfEl.value : '';
        statusEl.textContent = 'Refining…';
        const panel = document.getElementById(kind === 'bg' ? 'bg-panel' : 'run-panel');
        if (panel) panel.classList.add('loading');
        refineBtn.disabled = true;
        try {
          const res = await fetch({{ url_for('refine')|tojson }}, {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ study_background: sb, theoretical_framework: tf, analysis_mode: mode, openai_api_key: key })
          });
          const data = await res.json();
          if (!data.ok) { statusEl.textContent = 'Refine failed: ' + (data.error || 'Unknown'); return; }
          if (kind === 'bg') {
            if (!snapshots.bg) snapshots.bg = sb;
            if (data.study_background) {
              sbEl.value = data.study_background;
              if (bgLimiter && typeof bgLimiter.update === 'function') bgLimiter.update();
            }
          } else {
            if (!snapshots.tf) snapshots.tf = tf;
            if (tfEl && (data.theoretical_framework !== undefined)) {
              tfEl.value = data.theoretical_framework;
              if (tfLimiter && typeof tfLimiter.update === 'function') tfLimiter.update();
            }
          }
          revertBtn.disabled = false;
          statusEl.textContent = 'Refined. You can edit or revert.';
        } catch (e) {
          statusEl.textContent = 'Refine failed.';
        } finally {
          refineBtn.disabled = false;
          if (panel) panel.classList.remove('loading');
        }
      }
      function revertField(kind) {
        const statusEl = document.getElementById(kind === 'bg' ? 'status_bg' : 'status_tf');
        const revertBtn = document.getElementById(kind === 'bg' ? 'revert_bg_btn' : 'revert_tf_btn');
        if (kind === 'bg') {
          if (!snapshots.bg) { statusEl.textContent = 'Nothing to revert.'; return; }
          const sbEl = document.getElementById('study_background');
          if (sbEl) {
            sbEl.value = snapshots.bg;
            snapshots.bg = null;
            if (bgLimiter && typeof bgLimiter.update === 'function') bgLimiter.update();
          }
        } else {
          if (!snapshots.tf) { statusEl.textContent = 'Nothing to revert.'; return; }
          const tfEl = document.getElementById('theoretical_framework');
          if (tfEl) {
            tfEl.value = snapshots.tf;
            snapshots.tf = null;
            if (tfLimiter && typeof tfLimiter.update === 'function') tfLimiter.update();
          }
        }
        revertBtn.disabled = true;
        statusEl.textContent = 'Reverted to original.';
      }
      document.getElementById('refine_bg_btn').addEventListener('click', () => refineField('bg'));
      document.getElementById('revert_bg_btn').addEventListener('click', () => revertField('bg'));
      const rtf = document.getElementById('refine_tf_btn');
      const revtf = document.getElementById('revert_tf_btn');
      if (rtf) rtf.addEventListener('click', () => refineField('tf'));
      if (revtf) revtf.addEventListener('click', () => revertField('tf'));

      // Block submit if API key is missing
      const form = document.getElementById('run_form');
      if (form) {
        form.addEventListener('submit', (e) => {
          const key = document.getElementById('openai_api_key')?.value || '';
          if (!key.trim()) {
            e.preventDefault();
            alert('Please enter your OpenAI API key to run the analysis.');
          }
        });
      }
    </script>
  </body>
  </html>
